function Fext = AM_VFC(f, K, normalize, phi, R)
% AM_VFC        Compute the vector field convolution (VFC) force field [1].
%     Fext = AM_VFC(f, K)
%     Fext = AM_VFC(f, K, normalize)
%     Fext = AM_VFC(f, K, normalize, phi)
%     Fext = AM_VFC(f, K, normalize, phi, R)
%   
%     Inputs
%     f           edge map, d1-by-d2 matrix for 2D, and d1-by-d2-by-d3 matrix for 3D.   
%     K           vector field kernel, generated by AM_VFK(), similar format as Fext.
%     normalize   0 - (default) the output Fext is not nomalized,
%                 1 - output is normalized, i.e., sum(Fext(y,x,:).^2) = 1 
%                     for 2D, sum(Fext(y,x,z,:).^2) = 1 for 3D.
%     phi         mixed VFC threshold of equation (22) in [1].
%     R           a 3-element vector, [Rx Ry Rz] define the spacing between 
%                 voxels for x, y and z dimension, default value is [1 1 1].
%               
%     Outputs
%     Fext        the VFC external force field. For 2D, d1-by-d2-by-2 matrix, 
%                 the force at (x,y) is [Fext(y,x,1) Fext(y,x,2)]. For 3D,
%                 d1-by-d2-by-d3-by-3 matrix, the force at (x,y,z) is
%                 [Fext(y,x,z,1) Fext(y,x,z,2) Fext(y,x,z,3)].
% 
%     Note that for memory saving reason, the output data class is single / float (32-bit).
%     
%     Example
%         See EXAMPLE_VFC, EXAMPLE_PIG.
%
%     See also AMT, AM_VFK, AM_PIG, AM_ISOLINE, AM_DEFORM, AC_INITIAL, AC_REMESH,
%     AC_DISPLAY, AM_GVF, EXAMPLE_VFC, EXAMPLE_PIG. 
% 
%     Reference
%     [1] Bing Li and Scott T. Acton, "Active contour external force using
%     vector field convolution for image segmentation," Image Processing,
%     IEEE Trans. on, vol. 16, pp. 2096-2106, 2007.  
%     [2] Bing Li and Scott T. Acton, "Automatic Active Model
%     Initialization via Poisson Inverse Gradient," Image Processing,
%     IEEE Trans. on, vol. 17, pp. 1406-1420, 2008.   
% 
% (c) Copyright Bing Li 2005 - 2009.

% Revision Log
%   02-11-2005  original
%   01-30-2009  minor bug fix

%% inputs check
if ~ismember(nargin, 2:5)
    error('Invalid inputs to AM_VFC!')
elseif nargin < 3,
    normalize = 0;
end

if ndims(K) - ndims(f) ~= 1,
    error('f doesn''t match K!')
end

fmin = min(f(:));
if fmin<0       % assume f are all positive, take care of negetive problem
    f = f-fmin;
end

%% Compute VFC - convlove f with K using FFT to speed up the process
if ndims(f) == 2, % 2D
    FFTsize = size(f) + size(K(:,:,1)) - 1;
    k = K(:,:,1) + j*K(:,:,2);      % consider the vectors as complex numbers
    temp = ifft2(fft2(f, FFTsize(1), FFTsize(2)) .* fft2(k, FFTsize(1), FFTsize(2)));

    % remove padded points
    rmv = (size(K(:,:,1)) - 1)/2;
    temp = temp(rmv(1)+1:end-rmv(1), rmv(2)+1:end-rmv(2), :);
    Fext(:,:,2) = imag(temp);
    Fext(:,:,1) = real(temp);
    
    % mixed VFC, equation (22) in [1]
    if nargin > 3 && ~isempty(phi),  % mix the VFC with the gradient
        if nargin == 4,
            [fx fy] = AM_gradient(f);
        else
            [fx fy] = AM_gradient(f, R);
        end

        if strcmp(phi,'auto') % try to determine phi adpatively
            I = double(sqrt(fx.*fx+fy.*fy));
            idx = find(im2bw(I,graythresh(I)));
        else
            idx = find(sqrt(fx.*fx+fy.*fy) > phi);
        end
            
        Fext(idx) = fx(idx);    % replace the output
        Fext(idx+numel(f)) = fy(idx);
    end

    if normalize,
        Fmag = sqrt(sum(Fext.*Fext,3))+eps;
        Fext(:,:,1) = Fext(:,:,1)./Fmag;
        Fext(:,:,2) = Fext(:,:,2)./Fmag;
    end
else % 3D
    FFTsize = size(f) + size(K(:,:,:,1)) - 1;
    fftf = fftn(f, FFTsize);    
    Fext(:,:,:,3) = real(ifftn(fftf .* fftn(K(:,:,:,3), FFTsize)));
    temp = ifftn(fftf .* fftn(K(:,:,:,1) + j*K(:,:,:,2), FFTsize));
    Fext(:,:,:,2) = imag(temp);
    Fext(:,:,:,1) = real(temp);
    clear temp fftf;
    
    % remove padded points
    rmv = (size(K(:,:,:,1)) - 1)/2;
    Fext = Fext(rmv(1)+1:end-rmv(1), rmv(2)+1:end-rmv(2), rmv(3)+1:end-rmv(3), :);

    if nargin > 3 && ~isempty(phi),  % mix the VFC with the gradient
        if nargin == 4,
            [fx fy fz] = AM_gradient(f);
        else
            [fx fy fz] = AM_gradient(f, R);
        end
        gm2 = fx.*fx+fy.*fy+fz.*fz;     % gradient magnitude square of f

        id = round(numel(gm2)*phi);
        gm2_sort = sort(gm2(:),'descend');
        idx = find(gm2 > gm2_sort(id));
        Fext(idx) = fx(idx);    % replace the output
        Fext(idx+numel(f)) = fy(idx);
        Fext(idx+numel(f)*2) = fz(idx);
    end
    if normalize,
        Fmag = sqrt(sum(Fext.*Fext,4))+eps;
        Fext(:,:,:,1) = Fext(:,:,:,1)./Fmag;
        Fext(:,:,:,2) = Fext(:,:,:,2)./Fmag;
        Fext(:,:,:,3) = Fext(:,:,:,3)./Fmag;
    end
end
